# -*- coding: utf-8 -*-
"""CarTracks.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15fPeDiM_ZscKAIehBK_o4UA1y4YDnlna

**Car Track Simulator**

This app takes a description of the entities in a (currently 2D) environment and simulates the movement of one type of entity (i.e., a "Car") and plots the tracks made by each of the tires.

Entities are currently restricted to rectangles and are given a size and starting position.  Cars are assumed to be steered by the front wheels only and follows the Ackerman steering geometry.

Car motion is defined by a list of tuples that contain: carID, steering angle, velocity, and duration.  The motion specs are executed in the order in which they appear in the list, and are simulated assuming an idealized environment -- i.e., no acceleration/decelleration time, no tire slippage, etc.

Car dimensions are parameterized and given default values from here: https://www.dimensions.com/element/passenger-vehicle-180-degree-turning-paths-radius

The simulation environment is defined to have the origin at the bottom left of corner, and all measurements are in metric units.  There are no defined limits to the space.

The following parameters define an *Entity*:
  * coordinates of the centroid
  * width
  * length

The following parameters define a *Car* (in addition to those inherited from Entity):
  * width [default 2.13m]
  * length [default 5.79m]
  * front axle offset from front [default 0.91m]
  * rear axle offset from rear [default 1.52m]
  * distance between wheels [default 1.83m]
  * minimum turning radius (of outside front wheel) [default 7.31m]
  * maximum steering angle [default +/- 31.6deg]
  * coordinates of current location of centroid
  * steering angle (degrees from straight ahead) [default 0deg]
  * velocity [default 0m/sec]
  * aziumuth (0 deg is up) [default 0deg]

The configuration of this simulator is given by a YAML file, and the list of Car motion tuples are also given as a YAML file (that can be generated manually or from some path generation program).

**TODO**

* add more than one *Car*
* convert all *Entities* to 3D
* detect collisions (i.e., intersecting *Entities*)
* automate generation of movement lists
"""

from dataclasses import dataclass
from enum import Enum
import matplotlib as mpl
import matplotlib.patches as patches
from matplotlib.path import Path
import matplotlib.pyplot as plt
import numpy as np
import os
import sys
import yaml

class EntityType(Enum):
  STATIC = 0
  DYNAMIC = 1

@dataclass
class Coordinate:
  x: float
  y: float

  def __add__(self, other):
    new = Coordinate(self.x, self.y)
    new.x += other.x
    new.y += other.y
    return new

  def __sub__(self, other):
    new = Coordinate(self.x, self.y)
    new.x -= other.x
    new.x = new.x if new.x >= 0.0 else 0.0
    new.y -= other.y
    new.y = new.y if new.y >= 0.0 else 0.0

@dataclass
class Motion:
  steeringAngle: float
  velocity: float
  duration: float

CAR_DEFAULTS = {
    'centroid': Coordinate(0,0),
    'width': 2.13,
    'length': 5.79,
    'frontAxleOffset': 0.91,
    'rearAxleOffset': 1.52,
    'wheelDistance': 1.83,
    'tireDiameter': .83,
    'minTurnRadius': 7.31,
    'maxSteeringAngle': (-31.6, 31.6),
    'velocity': 0,
    'azimuth': 0
}

"""The Entity object encapsulates all of the state of a (currently 2D) shape within the simulation environment."""

class Entity():
    def __init__(self, centroid, width, length):
      if not isinstance(centroid, Coordinate):
        raise TypeError("centroid must be a Coordinate")
      self.centroid = centroid
      if width < 0:
        raise ValueError("width must be non-negative")
      self.width = width
      if length < 0:
        raise ValueError("length must be non-negative")
      self.length = length
      
      self.x1 = self.centroid.x - (self.width / 2)
      if self.x1 < 0:
        raise ValueError("Entity lies outside the simulation space")
      self.x2 = self.centroid.x + (self.width / 2)
      self.y1 = self.centroid.y - (self.length / 2)
      if self.y1 < 0:
        raise ValueError("Entity lies outside the simulation space")
      self.y2 = self.centroid.y + (self.length / 2)

    def __repr__(self):
      return f"Entity: centroid={self.centroid}, width={self.width}, length={self.length}"

    def render(self, ax, color="gray"):
      vertices = [
                  (self.x1, self.y1), # BL
                  (self.x1, self.y2), # LT
                  (self.x2, self.y2), # RT
                  (self.x2, self.y1),  # RB
                  (0.0, 0.0)
      ]
      codes = [
               Path.MOVETO,
               Path.LINETO,
               Path.LINETO,
               Path.LINETO,
               Path.CLOSEPOLY
      ]
      path = Path(vertices, codes)
      patch = patches.PathPatch(path, facecolor=color, lw=2)
      ax.add_patch(patch)

"""The Car object is a subclass of Entity, has more state and the ability to move."""

class Car(Entity):
  def __init__(self, **kwargs):
    super().__init__(kwargs['centroid'], kwargs['width'], kwargs['length'])
    for arg, val in kwargs.items():
      if arg not in kwargs:
        kwargs[arg] = CAR_DEFAULTS[arg]
    #### TODO test validity of inputs
    self.frontAxleOffset = kwargs['frontAxleOffset']
    self.rearAxleOffset = kwargs['rearAxleOffset']
    self.wheelDistance = kwargs['wheelDistance']
    self.tireDiameter = kwargs['tireDiameter']
    self.minTurnRadius = kwargs['minTurnRadius']
    self.maxSteeringAngle = kwargs['maxSteeringAngle']
    self.velocity = kwargs['velocity']
    self.azimuth = kwargs['azimuth']
    self.lrTire = Coordinate(self.x1, self.y1 + self.rearAxleOffset)
    self.rrTire = Coordinate(self.x2, self.y1 + self.rearAxleOffset)
    self.frontAxleY = self.y2 - self.frontAxleOffset
    self.frontAxelPivot = Coordinate(centroid.x, self.y2 - self.frontAxleOffset)
    self.rearAxleY = self.y1 + self.rearAxleOffset

  def __repr__(self):
    return f"Car: {self.__dict__}"

  def render(self, ax):
    super().render(ax, color="lightblue")

    rearAxle_Tires = [
                (Path.MOVETO, (self.x1, self.rearAxleY)),
                (Path.LINETO, (self.x2, self.rearAxleY)),
                (Path.MOVETO, (self.x2, self.rearAxleY - (self.tireDiameter / 2))),
                (Path.LINETO, (self.x2, self.rearAxleY + (self.tireDiameter / 2))),
                (Path.MOVETO, (self.x1, self.rearAxleY - (self.tireDiameter / 2))),
                (Path.LINETO, (self.x1, self.rearAxleY + (self.tireDiameter / 2)))
    ]
    codes, vertices = zip(*rearAxle_Tires)
    path = Path(vertices, codes)
    patch = patches.PathPatch(path, color="red", lw=2)
    ax.add_patch(patch)

    frontAxle = [
                (Path.MOVETO, (self.x1, self.frontAxleY)),
                (Path.LINETO, (self.x2, self.frontAxleY))
    ]
    codes, vertices = zip(*frontAxle)
    path = Path(vertices, codes)
    patch = patches.PathPatch(path, color="green", lw=2)
    ax.add_patch(patch)
  
  def move(self, motion):
    pass

"""You add *Entities* to the *Simulator*, give it a movement list, and then run it (either to completion, or single-step).  The *Simulator* will render the current position of all *Cars* after each movement."""

class Simulator():
  def __init__(self, config):
    # N.B. entity names must be unique, only the last of any duplicates will be kept, does this silently
    #### TODO rethink this
    self.static = {}
    self.dynamic = {}
    self.minX = self.minY = sys.maxsize
    self.maxX = self.maxY = 0
    for entitySpec in config:
      if entitySpec['type'] == EntityType.STATIC:
        entity = Entity(Coordinate(*entitySpec['location']), entitySpec['width'], entitySpec['length'])
        self.static[entitySpec['name']] = entity
      else:
        entity = Car(**entitySpec)
        self.dynamic[entitySpec['name']] = entity
      self.minX = entity.x1 if entity.x1 < self.minX else self.minX
      self.maxX = entity.x2 if entity.x2 > self.maxX else self.maxX
      self.minY = entity.y1 if entity.y1 < self.minY else self.minY
      self.maxY = entity.y2 if entity.y2 > self.maxY else self.maxY
    self.X_MARGIN = 1
    self.Y_MARGIN = 1

  def _render(self):
    fig, ax = plt.subplots()
    entities = {**self.static, **self.dynamic}
    for entity in entities.values():
      entity.render(ax)
    minX = self.minX - self.X_MARGIN if (self.minX - self.X_MARGIN) >= 0 else 0
    maxX = self.maxX + self.X_MARGIN
    minY = self.minY - self.Y_MARGIN if (self.minY - self.Y_MARGIN) >= 0 else 0
    maxY = self.maxY + self.Y_MARGIN
    ax.set_xlim(minX, maxX)
    ax.set_ylim(minY, maxY)
    ax.set_aspect('equal')
    plt.show()

  def _move(self):
    pass

  def singleStep(self, movements):
    pass
  
  def nextStep(self):
    pass

  def run(self, movements):
    self._render()

"""Start by instantiating the Simulator and pass it a configuration dict.  It will construct all of the specified entities.  Then give the Simulator a movement dict, and then run the Simulator in the desired mode (i.e., single-step or run to completion)."""

#### TODO get config from file
carParameters = CAR_DEFAULTS.copy()
carParameters['centroid'] = Coordinate(20, 25)
config = [
    {'name': "box1", 'type': EntityType.STATIC, 'width': 10, 'length': 10, 'location': (10, 10)},
    {'name': "box2", 'type': EntityType.STATIC, 'width': 5, 'length': 25, 'location': (30, 20)},
    {'name': "car", 'type': EntityType.DYNAMIC, **carParameters}
]
sim = Simulator(config)

#### TODO get movements from file
moves = {}
sim.run(moves)